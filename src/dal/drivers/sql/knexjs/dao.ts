import { DAOParams, FindParams, FindOneParams, FilterParams, InsertParams, UpdateParams, ReplaceParams, DeleteParams } from '../../../dao/dao.types'
import { PartialDeep } from 'type-fest'
import { deepCopy, setTraversing, replaceType } from '@twinlogix/tl-commons'
import Bignumber from 'bignumber.js'
import { AbstractDAOContext } from '../../../daoContext/daoContext'
import { AbstractDAO } from '../../../dao/dao'
import { AnyProjection, GenericProjection, ModelProjection, Projection } from '../../../dao/projections/projections.types'
import knex, { Knex } from 'knex'
import { ComparisonOperators, ElementOperators, EvaluationOperators } from '../../../dao/filters/filters.types'
import { Schema } from '../../drivers.types'
import { buildSelect, buildSort, buildWhereConditions } from './utils'
import { transformObject } from '../../../../generation/utils'

type AbstractFilter = {
  [key: string]: any | null | ComparisonOperators<any> | ElementOperators<any> | EvaluationOperators<any>
}

export abstract class AbstractMongooseDAO<
  ModelType extends object,
  IDKey extends keyof Omit<ModelType, ExcludedFields>,
  IDAutogenerated extends boolean,
  FilterType extends AbstractFilter,
  SortType,
  UpdateType,
  ExcludedFields extends keyof ModelType,
  OptionsType extends { knex?: any },
> extends AbstractDAO<ModelType, IDKey, IDAutogenerated, FilterType, SortType, UpdateType, ExcludedFields, OptionsType> {
  private collectionName: string
  private schema: Schema<any>

  protected constructor({
    collectionName,
    schema,
    ...params
  }: { idField: IDKey; daoContext: AbstractDAOContext; collectionName: string; schema: Schema<any> } & DAOParams<
    ModelType,
    IDKey,
    IDAutogenerated,
    FilterType,
    UpdateType,
    ExcludedFields,
    SortType,
    OptionsType
  >) {
    super(params)
    this.collectionName = collectionName
    this.schema = schema
  }

  config: Knex.Config = {
    client: 'sqlite3',
    connection: {
      filename: './data.db',
    },
  }
  knexInstance = knex(this.config)

  private mapObjects(objects: PartialDeep<ModelType>[]): PartialDeep<ModelType>[] {
    return objects.map((obj) => transformObject<PartialDeep<ModelType>, any>(this.daoContext.adapters, 'dbToModel', obj as PartialDeep<ModelType>, this.schema, this.daoContext.adapters.get('JSON')))
  }

  protected async _find(params: FindParams<FilterType, Projection<ModelType>, SortType, OptionsType>): Promise<PartialDeep<ModelType>[]> {
    const partialQuery1 = buildSelect(this.knexInstance(this.collectionName), params.projection as GenericProjection)
    const partialQuery2 = buildWhereConditions(partialQuery1, params.filter as AbstractFilter, this.schema, this.daoContext.adapters)
    const query = buildSort(partialQuery2, params.sorts || [])
    const results = await query.limit(params.limit || this.pageSize).offset(params.start || 0)
    return this.mapObjects(results)
  }
  protected _findOne(params: FindOneParams<FilterType, Projection<ModelType>, OptionsType>): Promise<PartialDeep<ModelType> | null> {
    throw new Error('Method not implemented.')
  }
  protected _findPage(params: FindParams<FilterType, Projection<ModelType>, SortType, OptionsType>): Promise<{ totalCount: number; records: PartialDeep<ModelType>[] }> {
    throw new Error('Method not implemented.')
  }
  protected _exists(params: FilterParams<FilterType, OptionsType>): Promise<boolean> {
    throw new Error('Method not implemented.')
  }
  protected _count(params: FilterParams<FilterType, OptionsType>): Promise<number> {
    throw new Error('Method not implemented.')
  }
  protected _insertOne(params: InsertParams<ModelType, IDKey, ExcludedFields, IDAutogenerated, OptionsType>): Promise<Omit<ModelType, ExcludedFields>> {
    throw new Error('Method not implemented.')
  }
  protected _updateOne(params: UpdateParams<FilterType, UpdateType, OptionsType>): Promise<void> {
    throw new Error('Method not implemented.')
  }
  protected _updateMany(params: UpdateParams<FilterType, UpdateType, OptionsType>): Promise<void> {
    throw new Error('Method not implemented.')
  }
  protected _replaceOne(params: ReplaceParams<FilterType, ModelType, ExcludedFields, OptionsType>): Promise<void> {
    throw new Error('Method not implemented.')
  }
  protected _deleteOne(params: DeleteParams<FilterType, OptionsType>): Promise<void> {
    throw new Error('Method not implemented.')
  }
  protected _deleteMany(params: DeleteParams<FilterType, OptionsType>): Promise<void> {
    throw new Error('Method not implemented.')
  }
}
