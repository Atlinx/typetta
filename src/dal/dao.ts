import DataLoader from 'dataloader'
import objectHash from 'object-hash'
import { AbstractDAOContext } from './daoContext'
import { ConditionalPartialBy } from '../utils/utils'
import { PartialDeep } from 'type-fest'
import { deepMerge, getTraversing, setTraversing } from '@twinlogix/tl-commons'
import { Projection, ModelProjection, StaticProjection, GenericProjection, AnyProjection } from '../utils/types'
import { projection, getProjection, isProjectionIntersected, mergeProjections } from '../utils/projection'
import _ from 'lodash'

export enum SortDirection {
  ASC = 1,
  DESC = -1,
}

export type LogicalOperators<FilterType> = {
  $and?: LogicalOperators<FilterType>[] | FilterType[]
  $not?: LogicalOperators<FilterType> | FilterType
  $nor?: LogicalOperators<FilterType>[] | FilterType[]
  $or?: LogicalOperators<FilterType>[] | FilterType[]
}

export type ComparisonOperators<FieldType> = {
  $eq?: FieldType
  $gt?: FieldType
  $gte?: FieldType
  $in?: FieldType[]
  $lt?: FieldType
  $lte?: FieldType
  $ne?: FieldType
  $nin?: FieldType[]
}

export type ElementOperators<FieldType> = {
  $exists?: Boolean
  // $type
}

export type EvaluationOperators<FieldType> = {
  // $expr?
  // $jsonSchema
  // $mod
  // $regex
  $text?: {
    $search: String
    $language?: String
    $caseSensitive?: Boolean
    $diacriticSensitive?: Boolean
  }
  // $where
}

export type GeospathialOperators<FieldType> = {
  // $geoIntersect
  // $geoWithin
  $near?: {
    $geometry: {
      type: 'Point'
      coordinates: number[]
    }
    $maxDistance?: number
    $minDistance: number
  }
  $nearSphere?: {
    $geometry: {
      type: 'Point'
      coordinates: number[]
    }
    $maxDistance?: number
    $minDistance: number
  }
}

export type ArrayOperators<FieldType> = {
  $all?: FieldType[]
  // $elemMatch
  $size: number
}

export type ReadOptions = {
  secure?: boolean
  _?: any
}

export type ReadFromCacheOptions<ProjectionType> = ReadOptions & {
  onlyFromCache?: boolean
  projections?: ProjectionType
}

export type WriteOptions = {
  secure?: boolean
  _?: any
}

export type ReferenceChecksResponse<T> =
  | true
  | {
      association: DAOAssociation
      record: PartialDeep<T>
      failedReferences: any[]
    }[]

export enum DAOAssociationType {
  ONE_TO_ONE,
  ONE_TO_MANY,
}

export enum DAOAssociationReference {
  INNER,
  FOREIGN,
}

export type DAOAssociation = {
  type: DAOAssociationType
  reference: DAOAssociationReference
  field: string //TODO: use recursivekeyof
  refFrom: string
  refTo: string
  dao: string
  buildFilter?: (keys: any[]) => any
  hasKey?: (record: any, key: any) => boolean
  extractField?: string
}

export type DAOComputedFields<ModelType, P extends true | StaticProjection<ModelType> | undefined | Projection<ModelType>> = {
  fieldsProjection: Projection<ModelType>
  requiredProjection: P
  compute: (record: ModelProjection<ModelType, P>) => Promise<PartialDeep<ModelType>>
}

export function projectionDependency<M, P extends StaticProjection<M>>(args: { fieldsProjection: Projection<M>; requiredProjection: P }): DAOMiddleware<M, any, true, any, any, never, any> {
  return {
    beforeFind: async (findParams) => {
      if (isProjectionIntersected(findParams.projection ? (findParams.projection as GenericProjection) : true, args.fieldsProjection ? (args.fieldsProjection as GenericProjection) : true)) {
        return {
          ...findParams,
          projection: mergeProjections((findParams.projection || true) as GenericProjection, args.requiredProjection as GenericProjection) as Projection<M>,
        }
      }
      return findParams
    },
  }
}

export function buildComputedField<M, P extends StaticProjection<M>>(args: { fieldsProjection: Projection<M>; requiredProjection: P; compute: (record: ModelProjection<M, P>) => Promise<PartialDeep<M>> }): DAOMiddleware<M, any, true, any, any, never, any> {
  return {
    beforeFind: projectionDependency(args).beforeFind,
    afterFind: async (findParams, result) => {
      if (result && isProjectionIntersected(findParams.projection ? (findParams.projection as GenericProjection) : true, args.fieldsProjection ? (args.fieldsProjection as GenericProjection) : true)) {
        return deepMerge(result, await args.compute(result as ModelProjection<M, P>))
      }
      return result
    },
  }
}

export type DAOResolver = {
  load: (parents: any[], projections: any) => Promise<any[]>
  match: (source: any, value: any) => boolean
}

export type FilterParams<FilterType> = {
  filter?: FilterType
  options?: ReadOptions
}
export type FindOneParams<FilterType, ProjectionType> = FilterParams<FilterType> & {
  projection?: ProjectionType
}
export type FindParams<FilterType, ProjectionType, SortType> = FindOneParams<FilterType, ProjectionType> & {
  start?: number
  limit?: number
  sort?: SortType
}

export interface DAO<DBRef, DBObj, ModelType, IDKey extends keyof Omit<ModelType, ExcludedFields>, IDAutogenerated extends boolean, FilterType, SortType, UpdateType, ExcludedFields extends keyof ModelType> {
  find<ProjectionType extends AnyProjection<ModelType> = true>(params: FindParams<FilterType, ProjectionType, SortType>): Promise<ModelProjection<ModelType, ProjectionType>[]>
  findOne<ProjectionType extends AnyProjection<ModelType> = true>(params: FindOneParams<FilterType, ProjectionType>): Promise<ModelProjection<ModelType, ProjectionType> | null>
  findPage<ProjectionType extends AnyProjection<ModelType> = true>(params: FindParams<FilterType, ProjectionType, SortType>): Promise<{ totalCount: number; records: ModelProjection<ModelType, ProjectionType>[] }>
  //findByQuery(query: (dbRef: DBRef, dbProjections: any, dbSorts?: any, start?: number, limit?: number, options?: any) => Promise<DBObj[]>, projections?: Projection<ModelType>, options?: ReadOptions): Promise<ModelType[]>

  load(keys: any[], buildFilter: (keys: any[]) => FilterType, hasKey: (record: ModelType, key: any) => boolean, projections?: Projection<ModelType>, loaderIdetifier?: string, options?: ReadOptions): Promise<(ModelType | null | Error)[]>
  checkReferences(records: PartialDeep<ModelType> | PartialDeep<ModelType>[], options?: ReadOptions): Promise<ReferenceChecksResponse<ModelType>>
  exists(params: FilterParams<FilterType>): Promise<boolean>
  count(params: FilterParams<FilterType>): Promise<number>

  insert(record: ConditionalPartialBy<Omit<ModelType, ExcludedFields>, IDKey, IDAutogenerated>, options?: WriteOptions): Promise<ModelType>
  update<T extends Pick<ModelType, IDKey>>(record: T, changes: UpdateType, options?: WriteOptions): Promise<void>
  updateOne(filter: FilterType, changes: UpdateType, options?: WriteOptions): Promise<void>
  updateMany(filter: FilterType, changes: UpdateType, options?: WriteOptions): Promise<void>
  replace<T extends Pick<ModelType, IDKey>>(from: T, to: Omit<ModelType, ExcludedFields>, options?: WriteOptions): Promise<void>
  replaceOne(filter: FilterType, to: Omit<ModelType, ExcludedFields>, options?: WriteOptions): Promise<void>
  delete<T extends Pick<ModelType, IDKey>>(record: T, options?: WriteOptions): Promise<void>
  deleteOne(filter: FilterType, options?: WriteOptions): Promise<void>
  deleteMany(filter: FilterType, options?: WriteOptions): Promise<void>
}

export type DAOMiddleware<ModelType, IDKey extends keyof Omit<ModelType, ExcludedFields>, IDAutogenerated extends boolean, FilterType, UpdateType, ExcludedFields extends keyof ModelType, SortType> = {
  beforeFind?: (args: FindParams<FilterType, Projection<ModelType>, SortType>) => Promise<FindParams<FilterType, Projection<ModelType>, SortType>>
  afterFind?: (args: FindParams<FilterType, Projection<ModelType>, SortType>, result: PartialDeep<ModelType> | null) => Promise<PartialDeep<ModelType>>

  beforeInsert?: (record: Readonly<ConditionalPartialBy<Omit<ModelType, ExcludedFields>, IDKey, IDAutogenerated>>) => Promise<void | { error: Error } | { record: ConditionalPartialBy<Omit<ModelType, ExcludedFields>, IDKey, IDAutogenerated> }>
  afterInsert?: (record: Readonly<ConditionalPartialBy<Omit<ModelType, ExcludedFields>, IDKey, IDAutogenerated>>, result: Readonly<ModelType>) => Promise<void>

  beforeUpdate?: (filter: Readonly<FilterType>, changes: Readonly<UpdateType>) => Promise<void | { cancel: boolean; error?: Error } | { changes: UpdateType }>
  afterUpdate?: (filter: Readonly<FilterType>, changes: Readonly<UpdateType>) => Promise<void>

  beforeReplace?: (filter: Readonly<FilterType>, to: Readonly<Omit<ModelType, ExcludedFields>>) => Promise<void | { cancel: boolean; error?: Error } | { to: Omit<ModelType, ExcludedFields> }>
  afterReplace?: (filter: Readonly<FilterType>, to: Readonly<Omit<ModelType, ExcludedFields>>) => Promise<void>

  beforeDelete?: (filter: Readonly<FilterType>) => Promise<void | { cancel: boolean; error?: Error }>
  afterDelete?: (filter: Readonly<FilterType>) => Promise<void>
}

export interface DAOParams<ModelType, IDKey extends keyof Omit<ModelType, ExcludedFields>, IDAutogenerated extends boolean, FilterType, UpdateType, ExcludedFields extends keyof ModelType, SortType> {
  pageSize?: number
  associations?: DAOAssociation[]
  middlewares?: DAOMiddleware<ModelType, IDKey, IDAutogenerated, FilterType, UpdateType, ExcludedFields, SortType>[]
}

export abstract class AbstractDAO<DBRef, DBObj, ModelType, IDKey extends keyof Omit<ModelType, ExcludedFields>, IDAutogenerated extends boolean, FilterType, SortType, UpdateType, ExcludedFields extends keyof ModelType> implements DAO<DBRef, DBObj, ModelType, IDKey, IDAutogenerated, FilterType, SortType, UpdateType, ExcludedFields> {
  protected idField: IDKey
  protected daoContext: AbstractDAOContext
  protected associations: DAOAssociation[]
  protected middlewares: DAOMiddleware<ModelType, IDKey, IDAutogenerated, FilterType, UpdateType, ExcludedFields, SortType>[]
  protected pageSize: number
  protected resolvers: { [key: string]: DAOResolver | undefined }
  protected dataLoaders: Map<string, DataLoader<ModelType[IDKey], ModelType[] | null>>

  protected constructor({ idField, daoContext, pageSize = 50, associations = [], middlewares = [] }: { idField: IDKey; daoContext: AbstractDAOContext } & DAOParams<ModelType, IDKey, boolean, FilterType, any, ExcludedFields, SortType>) {
    this.dataLoaders = new Map<string, DataLoader<ModelType[IDKey], ModelType[]>>()
    this.idField = idField
    this.daoContext = daoContext
    this.pageSize = pageSize
    this.resolvers = {}
    this.associations = associations
    this.associations.forEach((association) => this.addResolver(association))
    this.middlewares = middlewares
  }

  private async beforeFind(params: FindParams<FilterType, Projection<ModelType>, SortType>): Promise<FindParams<FilterType, Projection<ModelType>, SortType>> {
    for (const middleware of this.middlewares) {
      if (middleware.beforeFind) {
        params = await middleware.beforeFind(params)
      }
    }
    return params
  }

  private async afterFind(params: FindParams<FilterType, Projection<ModelType>, SortType>, result: PartialDeep<ModelType>): Promise<PartialDeep<ModelType>> {
    for (const middleware of this.middlewares) {
      if (middleware.afterFind) {
        result = await middleware.afterFind(params, result)
      }
    }
    return result
  }

  private async elabRecords<P extends AnyProjection<ModelType>>(params: FindParams<FilterType, P, SortType>, records: PartialDeep<ModelType>[]): Promise<ModelProjection<ModelType, P>[]> {
    const results = (await this._find(params))
    for (let i = 0; i < results.length; i++) {
      results[i] = await this.afterFind(params, results[i])
    }
    return results as ModelProjection<ModelType, P>[]
  }

  async find<P extends AnyProjection<ModelType> = true>(params: FindParams<FilterType, P, SortType>): Promise<ModelProjection<ModelType, P>[]> {
    const newParams = await this.beforeFind(params)
    const records = (await this._find(newParams))
    return this.elabRecords(params, records)
  }

  async findOne<P extends AnyProjection<ModelType> = true>(params: FindOneParams<FilterType, P>): Promise<ModelProjection<ModelType, P> | null> {
    const newParams = await this.beforeFind({ ...params })
    const record = (await this._findOne(newParams))
    if (record) {
      return (await this.elabRecords({ ...params }, [record]))[0]
    }
    return null
  }

  async findPage<P extends AnyProjection<ModelType> = true>(params: FindParams<FilterType, P, SortType>): Promise<{ totalCount: number; records: ModelProjection<ModelType, P>[] }> {
    const newParams = await this.beforeFind(params)
    const { totalCount, records } = await this._findPage(newParams)
    return { totalCount, records: await this.elabRecords(params, records as PartialDeep<ModelType>[]) }
  }

  async exists(params: FilterParams<FilterType>): Promise<boolean> {
    const newParams = await this.beforeFind({ ...params })
    return this._exists(newParams)
  }

  async count(params: FilterParams<FilterType>): Promise<number> {
    const newParams = await this.beforeFind({ ...params })
    return this._count(newParams)
  }

  // -----------------------------------------------------------------------
  // ------------------------------ ABSTRACTS ------------------------------
  // -----------------------------------------------------------------------
  protected abstract _find(params: FindParams<FilterType, Projection<ModelType>, SortType>): Promise<PartialDeep<ModelType>[]>

  protected abstract _findOne(params: FindOneParams<FilterType, Projection<ModelType>>): Promise<PartialDeep<ModelType> | null>

  protected abstract _findPage(params: FindParams<FilterType, Projection<ModelType>, SortType>): Promise<{ totalCount: number; records: PartialDeep<ModelType>[] }>

  //protected abstract _findByQuery(query: (dbRef: DBRef, dbProjections: any) => Promise<DBObj[]>, projections?: Projection<ModelType>, sorts?: SortType, start?: number, limit?: number, options?: ReadOptions): Promise<ModelType[]>

  protected abstract _exists(params: FilterParams<FilterType>): Promise<boolean>

  protected abstract _count(params: FilterParams<FilterType>): Promise<number>

  async checkReferences(records: PartialDeep<ModelType> | PartialDeep<ModelType>[], options?: ReadOptions): Promise<ReferenceChecksResponse<ModelType>> {
    const errors = []
    if (records) {
      const inputRecords = records instanceof Array ? records : [records]
      for (const association of this.associations) {
        if (association.reference === DAOAssociationReference.INNER) {
          const associationProjection = {}
          setTraversing(associationProjection, association.refTo, true)
          const resolver: DAOResolver = this.resolvers[association.field]!

          const associationFieldPathSplitted = association.field.split('.')
          associationFieldPathSplitted.pop()
          const parentPath = associationFieldPathSplitted.join('.')
          const parents = getTraversing(inputRecords, parentPath)
          const associatedRecords = await resolver.load(parents, associationProjection)

          for (const inputRecord of inputRecords) {
            const notFoundRefsFrom = getTraversing(inputRecord, association.refFrom).filter((refFrom) => {
              return !associatedRecords.find((associatedRecord) => associatedRecord && getTraversing(associatedRecord, association.refTo).length > 0 && refFrom === getTraversing(associatedRecord, association.refTo)[0])
            })
            if (notFoundRefsFrom.length > 0) {
              errors.push({ association, record: inputRecord, failedReferences: notFoundRefsFrom })
            }
          }
        }
      }
    }
    if (errors.length > 0) {
      return errors
    } else {
      return true
    }
  }

  // -----------------------------------------------------------------------
  // ---------------------------- ASSOCIATIONS -----------------------------
  // -----------------------------------------------------------------------
  async load(keys: any[], buildFilter: (keys: any[]) => FilterType, hasKey: (record: ModelType, key: any) => boolean, projections: Projection<ModelType>, loaderIdetifier: string = '', options?: ReadOptions): Promise<(ModelType | null | Error)[]> {
    const dataLoader = this.getDataLoader(buildFilter, hasKey, projections, loaderIdetifier)
    const loadedResults = await dataLoader.loadMany(keys)
    const results = []
    for (const loadedResult of loadedResults) {
      if (loadedResult instanceof Error) {
        throw loadedResult
      } else if (loadedResult !== null) {
        results.push(...loadedResult)
      }
    }
    return this.elabRecords(results, undefined, projections, options?.secure)
  }

  protected getDataLoader(buildFilter: (keys: any[]) => FilterType, hasKey: (record: ModelType, key: any) => boolean, projections: Projection<ModelType>, loaderIdetifier: string): DataLoader<any, ModelType[] | null> {
    const hash = loaderIdetifier + '-' + objectHash(projections || null, { respectType: false, unorderedArrays: true })
    const dataLoader = this.dataLoaders.get(hash)
    if (dataLoader) {
      return dataLoader
    } else {
      const newDataLoader = new DataLoader<any, ModelType[] | null>(
        async (keys) => {
          const filter = buildFilter(keys as ModelType[IDKey][])
          const loadedResults: any[] = await this.find(filter, projections)
          const orderedResults = []
          for (const key of keys) {
            orderedResults.push(loadedResults.filter((loadedResult) => hasKey(loadedResult, key)) || null)
          }
          return orderedResults
        },
        {
          maxBatchSize: this.pageSize,
        },
      )
      this.dataLoaders.set(hash, newDataLoader)
      return newDataLoader
    }
  }

  protected async resolveAssociations(dbObjects: any[], projections?: Projection<ModelType>): Promise<ModelType[]> {
    for (const association of this.associations) {
      if (projections) {
        let associationProjection = getProjection(projections as GenericProjection, association.field)
        if (associationProjection && projections !== true) {
          if (associationProjection !== true) {
            if (association.reference === DAOAssociationReference.INNER) {
              setTraversing(associationProjection, association.refTo, true)
            } else if (association.reference === DAOAssociationReference.FOREIGN) {
              setTraversing(associationProjection, association.refFrom, true)
            }
          }
          const resolver: DAOResolver = this.resolvers[association.field]!

          const associationFieldPathSplitted = association.field.split('.')
          const associationField = associationFieldPathSplitted.pop()
          if (associationField) {
            const parentPath = associationFieldPathSplitted.join('.')
            const parents = getTraversing(
              dbObjects.filter((dbObject) => dbObject != null),
              parentPath,
            )
            const associatedRecords = await resolver.load(parents, associationProjection)
            parents.forEach((parent) => {
              if (association.type === DAOAssociationType.ONE_TO_ONE) {
                parent[associationField] =
                  associatedRecords.find((value) => {
                    return resolver.match(parent, value)
                  }) || null
              } else if (association.type === DAOAssociationType.ONE_TO_MANY) {
                parent[associationField] =
                  associatedRecords.filter((value) => {
                    return resolver.match(parent, value)
                  }) || null
              }
            })
          }
        }
      }
    }
    return dbObjects
  }

  protected addResolver(association: DAOAssociation) {
    let resolver

    if (association.reference === DAOAssociationReference.INNER) {
      const refFrom = association.refFrom.split('.').pop()
      const refTo = association.refTo
      const linkedDAO = association.dao
      if (refFrom) {
        if (association.type === DAOAssociationType.ONE_TO_ONE) {
          resolver = {
            load: async (parents: any[], projections: any) => {
              const ids = parents.map((parent) => parent[refFrom]).filter((value, index, self) => value !== null && value !== undefined && self.indexOf(value) === index)

              return this.daoContext.dao(linkedDAO).load(
                ids,
                association.buildFilter ||
                  ((keys: any[]): FilterType => {
                    // @ts-ignore
                    return { [refTo]: { $in: keys } }
                  }),
                association.hasKey ||
                  ((record: ModelType, key: any): boolean => {
                    return (record as any)[refTo] === key
                  }),
                projections,
                refTo,
              )
            },
            match: (source: any, value: any): boolean => {
              return source[refFrom] === value[refTo]
            },
          }
        } else if (association.type === DAOAssociationType.ONE_TO_MANY) {
          resolver = {
            load: async (parents: any[], projections: any) => {
              const ids = parents
                .map((parent) => parent[refFrom])
                .filter((value) => value !== null && value !== undefined)
                .reduce((a, c) => [...a, ...c], [])
                .filter((value: any[], index: number, self: any) => self.indexOf(value) === index)

              return this.daoContext.dao(linkedDAO).load(
                ids,
                association.buildFilter ||
                  ((keys: any[]): FilterType => {
                    // @ts-ignore
                    return { [refTo]: { $in: keys } }
                  }),
                association.hasKey ||
                  ((record: ModelType, key: any): boolean => {
                    return (record as any)[refTo] === key
                  }),
                projections,
                refTo,
              )
            },
            match: (source: any, value: any): boolean => {
              return source[refFrom] && source[refFrom].includes(value[refTo])
            },
          }
        }
      }
    } else if (association.reference === DAOAssociationReference.FOREIGN) {
      const refFrom = association.refFrom
      const refTo = association.refTo.split('.').pop()
      const linkedDAO = association.dao
      if (refTo) {
        resolver = {
          load: async (parents: any[], projections: any) => {
            const ids = parents.map((parent) => parent[refTo]).filter((value, index, self) => value !== null && value !== undefined && self.indexOf(value) === index)

            return this.daoContext.dao(linkedDAO).load(
              ids,
              association.buildFilter ||
                ((keys: any[]): FilterType => {
                  // @ts-ignore
                  return { [refFrom]: { $in: keys } }
                }),
              association.hasKey ||
                ((record: ModelType, key: any): boolean => {
                  return (record as any)[refFrom] === key
                }),
              projections,
              refFrom,
            )
          },
          match: (source: any, value: any): boolean => {
            const tmp = getTraversing(value, refFrom)
            return tmp.includes(source[refTo])
          },
        }
      }
    }
    this.resolvers[association.field] = resolver
  }

  protected idFilter<T extends Pick<ModelType, IDKey>>(model: T): FilterType {
    return { [this.idField]: model[this.idField] } as unknown as FilterType
  }

  private async beforeInsert(record: ConditionalPartialBy<Omit<ModelType, ExcludedFields>, IDKey, IDAutogenerated>): Promise<ConditionalPartialBy<Omit<ModelType, ExcludedFields>, IDKey, IDAutogenerated>> {
    for (const middleware of this.middlewares) {
      if (middleware.beforeInsert) {
        //TODO: why readonly not compiling?
        //@ts-ignore
        const res = await middleware.beforeInsert(record)
        if (res && 'error' in res) {
          throw res.error
        } else if (res && 'record' in res) {
          record = res.record
        }
      }
    }
    return record
  }

  private async afterInsert(record: ConditionalPartialBy<Omit<ModelType, ExcludedFields>, IDKey, IDAutogenerated>, result: ModelType) {
    for (const middleware of this.middlewares) {
      if (middleware.afterInsert) {
        //TODO: why readonly not compiling?
        //@ts-ignore
        await middleware.afterInsert(record, result)
      }
    }
  }

  async insert(record: ConditionalPartialBy<Omit<ModelType, ExcludedFields>, IDKey, IDAutogenerated>, options?: WriteOptions): Promise<ModelType> {
    const newRecord = await this.beforeInsert(record)
    const result = await this._insert(newRecord, options)
    await this.afterInsert(newRecord, result)
    return result
  }

  private async beforeUpdate(filter: FilterType, changes: UpdateType): Promise<UpdateType | null> {
    for (const middleware of this.middlewares) {
      if (middleware.beforeUpdate) {
        const res = await middleware.beforeUpdate(filter, changes)
        if (res && 'cancel' in res && res.cancel) {
          if (res.error) {
            throw res.error
          } else {
            return null
          }
        } else if (res && 'changes' in res) {
          changes = res.changes
        }
      }
    }
    return changes
  }

  private async afterUpdate(filter: FilterType, changes: UpdateType) {
    for (const middleware of this.middlewares) {
      if (middleware.afterUpdate) {
        await middleware.afterUpdate(filter, changes)
      }
    }
  }

  async update<T extends Pick<ModelType, IDKey>>(record: T, changes: UpdateType, options?: WriteOptions): Promise<void> {
    const filter = this.idFilter(record)
    const newChanges = await this.beforeUpdate(filter, changes)
    if (newChanges) {
      await this._updateOne(this.elabConditions(filter, options?.secure), newChanges, (options || {})._)
      await this.afterUpdate(filter, newChanges)
    }
  }

  async updateOne(conditions: FilterType, changes: UpdateType, options?: WriteOptions): Promise<void> {
    const newChanges = await this.beforeUpdate(conditions, changes)
    if (newChanges) {
      await this._updateOne(this.elabConditions(conditions, options?.secure), newChanges, options)
      await this.afterUpdate(conditions, newChanges)
    }
  }

  async updateMany(conditions: FilterType, changes: UpdateType, options?: WriteOptions): Promise<void> {
    const newChanges = await this.beforeUpdate(conditions, changes)
    if (newChanges) {
      await this._updateMany(this.elabConditions(conditions, options?.secure), newChanges, options)
      await this.afterUpdate(conditions, newChanges)
    }
  }

  private async beforeReplace(filter: FilterType, to: Omit<ModelType, ExcludedFields>): Promise<Omit<ModelType, ExcludedFields> | null> {
    for (const middleware of this.middlewares) {
      if (middleware.beforeReplace) {
        const res = await middleware.beforeReplace(filter, to)
        if (res && 'cancel' in res && res.cancel) {
          if (res.error) {
            throw res.error
          } else {
            return null
          }
        } else if (res && 'to' in res) {
          to = res.to
        }
      }
    }
    return to
  }

  private async afterReplace(filter: FilterType, to: Omit<ModelType, ExcludedFields>) {
    for (const middleware of this.middlewares) {
      if (middleware.afterReplace) {
        await middleware.afterReplace(filter, to)
      }
    }
  }

  async replace<T extends Pick<ModelType, IDKey>>(from: T, to: Omit<ModelType, ExcludedFields>, options?: WriteOptions): Promise<void> {
    const filter = this.idFilter(from)
    const newTo = await this.beforeReplace(filter, to)
    if (newTo) {
      await this._replaceOne(this.elabConditions(filter, options?.secure), newTo, options)
      await this.afterReplace(filter, newTo)
    }
  }

  async replaceOne(conditions: FilterType, to: Omit<ModelType, ExcludedFields>, options?: WriteOptions): Promise<void> {
    const newTo = await this.beforeReplace(conditions, to)
    if (newTo) {
      await this._replaceOne(this.elabConditions(conditions, options?.secure), newTo, options)
      await this.afterReplace(conditions, newTo)
    }
  }

  private async beforeDelete(filter: FilterType): Promise<true | null> {
    for (const middleware of this.middlewares) {
      if (middleware.beforeDelete) {
        const res = await middleware.beforeDelete(filter)
        if (res && res.cancel) {
          if (res.error) {
            throw res.error
          } else {
            return null
          }
        }
      }
    }
    return true
  }

  private async afterDelete(filter: FilterType) {
    for (const middleware of this.middlewares) {
      if (middleware.afterDelete) {
        await middleware.afterDelete(filter)
      }
    }
  }

  async delete<T extends Pick<ModelType, IDKey>>(record: T, options?: WriteOptions): Promise<void> {
    const filter = this.idFilter(record)
    const procede = await this.beforeDelete(filter)
    if (procede) {
      await this._deleteOne(this.elabConditions(filter, options?.secure), options)
      await this.afterDelete(filter)
    }
  }

  async deleteOne(conditions: FilterType, options?: WriteOptions): Promise<void> {
    const procede = await this.beforeDelete(conditions)
    if (procede) {
      await this._deleteOne(this.elabConditions(conditions, options?.secure), options)
      await this.afterDelete(conditions)
    }
  }

  async deleteMany(conditions: FilterType, options?: WriteOptions): Promise<void> {
    const procede = await this.beforeDelete(conditions)
    if (procede) {
      await this._deleteMany(this.elabConditions(conditions, options?.secure), options)
      await this.afterDelete(conditions)
    }
  }

  // -----------------------------------------------------------------------
  // ------------------------------ ABSTRACTS ------------------------------
  // -----------------------------------------------------------------------
  protected abstract _insert(record: ConditionalPartialBy<Omit<ModelType, ExcludedFields>, IDKey, IDAutogenerated>, options?: WriteOptions): Promise<ModelType>
  protected abstract _updateOne(filter: FilterType, changes: UpdateType, options?: WriteOptions): Promise<void>
  protected abstract _updateMany(filter: FilterType, changes: UpdateType, options?: WriteOptions): Promise<void>
  protected abstract _replaceOne(filter: FilterType, to: Omit<ModelType, ExcludedFields>, options?: WriteOptions): Promise<void>
  protected abstract _deleteOne(filter: FilterType, options?: WriteOptions): Promise<void>
  protected abstract _deleteMany(filter: FilterType, options?: WriteOptions): Promise<void>
}
