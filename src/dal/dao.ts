import DataLoader from 'dataloader'
import objectHash from 'object-hash'
import { AbstractDAOContext } from './daoContext'
import { ConditionalPartialBy } from '../utils/utils'
import { PartialDeep } from 'type-fest'
import { deepMerge, getTraversing, setTraversing } from '@twinlogix/tl-commons'
import { Projection, ModelProjection, StaticProjection, GenericProjection, AnyProjection } from '../utils/types'
import { projection, getProjection, isProjectionIntersected, mergeProjections } from '../utils/projection'
import _ from 'lodash'
import { DAOWrapperAPIv1 } from './daoWrapperAPIv1'

export enum SortDirection {
  ASC = 1,
  DESC = -1,
}

export type LogicalOperators<FilterType> = {
  $and?: LogicalOperators<FilterType>[] | FilterType[]
  $not?: LogicalOperators<FilterType> | FilterType
  $nor?: LogicalOperators<FilterType>[] | FilterType[]
  $or?: LogicalOperators<FilterType>[] | FilterType[]
}

export type ComparisonOperators<FieldType> = {
  $eq?: FieldType
  $gt?: FieldType
  $gte?: FieldType
  $in?: FieldType[]
  $lt?: FieldType
  $lte?: FieldType
  $ne?: FieldType
  $nin?: FieldType[]
}

export type ElementOperators<FieldType> = {
  $exists?: Boolean
  // $type
}

export type EvaluationOperators<FieldType> = {
  // $expr?
  // $jsonSchema
  // $mod
  // $regex
  $text?: {
    $search: String
    $language?: String
    $caseSensitive?: Boolean
    $diacriticSensitive?: Boolean
  }
  // $where
}

export type GeospathialOperators<FieldType> = {
  // $geoIntersect
  // $geoWithin
  $near?: {
    $geometry: {
      type: 'Point'
      coordinates: number[]
    }
    $maxDistance?: number
    $minDistance: number
  }
  $nearSphere?: {
    $geometry: {
      type: 'Point'
      coordinates: number[]
    }
    $maxDistance?: number
    $minDistance: number
  }
}

export type ArrayOperators<FieldType> = {
  $all?: FieldType[]
  // $elemMatch
  $size: number
}

export type ReferenceChecksResponse<T> =
  | true
  | {
      association: DAOAssociation
      record: PartialDeep<T>
      failedReferences: any[]
    }[]

export enum DAOAssociationType {
  ONE_TO_ONE,
  ONE_TO_MANY,
}

export enum DAOAssociationReference {
  INNER,
  FOREIGN,
}

export type DAOAssociation = {
  type: DAOAssociationType
  reference: DAOAssociationReference
  field: string //TODO: use recursivekeyof
  refFrom: string
  refTo: string
  dao: string
  buildFilter?: (keys: any[]) => any
  hasKey?: (record: any, key: any) => boolean
  extractField?: string
}

export type DAOComputedFields<ModelType, P extends true | StaticProjection<ModelType> | undefined | Projection<ModelType>> = {
  fieldsProjection: Projection<ModelType>
  requiredProjection: P
  compute: (record: ModelProjection<ModelType, P>) => Promise<PartialDeep<ModelType>>
}

export function projectionDependency<
  ModelType,
  P extends StaticProjection<ModelType>,
  IDKey extends keyof Omit<ModelType, ExcludedFields>,
  IDAutogenerated extends boolean,
  FilterType,
  UpdateType,
  ExcludedFields extends keyof ModelType,
  SortType,
  OptionsType,
>(args: { fieldsProjection: Projection<ModelType>; requiredProjection: P }): DAOMiddleware<ModelType, IDKey, IDAutogenerated, FilterType, UpdateType, ExcludedFields, SortType, OptionsType> {
  return {
    beforeFind: async (findParams) => {
      if (isProjectionIntersected(findParams.projection ? (findParams.projection as GenericProjection) : true, args.fieldsProjection ? (args.fieldsProjection as GenericProjection) : true)) {
        return {
          ...findParams,
          projection: mergeProjections((findParams.projection || true) as GenericProjection, args.requiredProjection as GenericProjection) as Projection<ModelType>,
        }
      }
      return findParams
    },
  }
}

export function buildComputedField<
  ModelType,
  P extends StaticProjection<ModelType>,
  IDKey extends keyof Omit<ModelType, ExcludedFields>,
  IDAutogenerated extends boolean,
  FilterType,
  UpdateType,
  ExcludedFields extends keyof ModelType,
  SortType,
  OptionsType,
>(args: {
  fieldsProjection: Projection<ModelType>
  requiredProjection: P
  compute: (record: ModelProjection<ModelType, P>) => Promise<PartialDeep<ModelType>>
}): DAOMiddleware<ModelType, IDKey, IDAutogenerated, FilterType, UpdateType, ExcludedFields, SortType, OptionsType> {
  return {
    beforeFind: projectionDependency<ModelType, P, IDKey, IDAutogenerated, FilterType, UpdateType, ExcludedFields, SortType, OptionsType>(args).beforeFind,
    afterFind: async (findParams, result) => {
      if (result && isProjectionIntersected(findParams.projection ? (findParams.projection as GenericProjection) : true, args.fieldsProjection ? (args.fieldsProjection as GenericProjection) : true)) {
        return deepMerge(result, await args.compute(result as ModelProjection<ModelType, P>))
      }
      return result
    },
  }
}

export type DAOResolver = {
  load: (parents: any[], projections: any) => Promise<any[]>
  match: (source: any, value: any) => boolean
}

export type FilterParams<FilterType, OptionsType> = {
  filter?: FilterType
  options?: OptionsType
}
export type FindOneParams<FilterType, ProjectionType, OptionsType> = FilterParams<FilterType, OptionsType> & {
  projection?: ProjectionType
}
export type FindParams<FilterType, ProjectionType, SortType, OptionsType> = FindOneParams<FilterType, ProjectionType, OptionsType> & {
  start?: number
  limit?: number
  sorts?: SortType
}

export type InsertParams<ModelType, IDKey extends keyof Omit<ModelType, ExcludedFields>, ExcludedFields extends keyof ModelType, IDAutogenerated extends boolean, OptionsType> = {
  record: ConditionalPartialBy<Omit<ModelType, ExcludedFields>, IDKey, IDAutogenerated>
  options?: OptionsType
}

export type UpdateParams<FilterType, UpdateType, OptionsType> = {
  filter: FilterType
  changes: UpdateType
  options?: OptionsType
}

export type ReplaceParams<FilterType, ModelType, ExcludedFields extends keyof ModelType, OptionsType> = {
  filter: FilterType
  replace: Omit<ModelType, ExcludedFields>
  options?: OptionsType
}

export type DeleteParams<FilterType, OptionsType> = {
  filter: FilterType
  options?: OptionsType
}

export interface DAO<
  ModelType,
  IDKey extends keyof Omit<ModelType, ExcludedFields>,
  IDAutogenerated extends boolean,
  FilterType,
  SortType,
  UpdateType,
  ExcludedFields extends keyof ModelType,
  OptionsType,
> {
  findAll<ProjectionType extends AnyProjection<ModelType> = true>(params: FindParams<FilterType, ProjectionType, SortType, OptionsType>): Promise<ModelProjection<ModelType, ProjectionType>[]>
  findOne<ProjectionType extends AnyProjection<ModelType> = true>(params: FindOneParams<FilterType, ProjectionType, OptionsType>): Promise<ModelProjection<ModelType, ProjectionType> | null>
  findPage<ProjectionType extends AnyProjection<ModelType> = true>(
    params: FindParams<FilterType, ProjectionType, SortType, OptionsType>,
  ): Promise<{ totalCount: number; records: ModelProjection<ModelType, ProjectionType>[] }>
  exists(params: FilterParams<FilterType, OptionsType>): Promise<boolean>
  count(params: FilterParams<FilterType, OptionsType>): Promise<number>
  checkReferences(records: PartialDeep<ModelType> | PartialDeep<ModelType>[], options?: OptionsType): Promise<ReferenceChecksResponse<ModelType>>
  insertOne(params: InsertParams<ModelType, IDKey, ExcludedFields, IDAutogenerated, OptionsType>): Promise<Omit<ModelType, ExcludedFields>>
  updateOne(params: UpdateParams<FilterType, UpdateType, OptionsType>): Promise<void>
  updateAll(params: UpdateParams<FilterType, UpdateType, OptionsType>): Promise<void>
  replaceOne(params: ReplaceParams<FilterType, ModelType, ExcludedFields, OptionsType>): Promise<void>
  deleteOne(params: DeleteParams<FilterType, OptionsType>): Promise<void>
  deleteAll(params: DeleteParams<FilterType, OptionsType>): Promise<void>
}

export type DAOMiddleware<
  ModelType,
  IDKey extends keyof Omit<ModelType, ExcludedFields>,
  IDAutogenerated extends boolean,
  FilterType,
  UpdateType,
  ExcludedFields extends keyof ModelType,
  SortType,
  OptionsType,
> = {
  beforeFind?: (params: FindParams<FilterType, Projection<ModelType>, SortType, OptionsType>) => Promise<FindParams<FilterType, Projection<ModelType>, SortType, OptionsType>>
  afterFind?: (params: FindParams<FilterType, Projection<ModelType>, SortType, OptionsType>, result: PartialDeep<ModelType>) => Promise<PartialDeep<ModelType>>
  beforeInsert?: (params: InsertParams<ModelType, IDKey, ExcludedFields, IDAutogenerated, OptionsType>) => Promise<InsertParams<ModelType, IDKey, ExcludedFields, IDAutogenerated, OptionsType>>
  afterInsert?: (params: InsertParams<ModelType, IDKey, ExcludedFields, IDAutogenerated, OptionsType>, result: Omit<ModelType, ExcludedFields>) => Promise<Omit<ModelType, ExcludedFields>>
  beforeUpdate?: (params: UpdateParams<FilterType, UpdateType, OptionsType>) => Promise<UpdateParams<FilterType, UpdateType, OptionsType>>
  afterUpdate?: (params: UpdateParams<FilterType, UpdateType, OptionsType>) => Promise<void>
  beforeReplace?: (params: ReplaceParams<FilterType, ModelType, ExcludedFields, OptionsType>) => Promise<ReplaceParams<FilterType, ModelType, ExcludedFields, OptionsType>>
  afterReplace?: (params: ReplaceParams<FilterType, ModelType, ExcludedFields, OptionsType>) => Promise<void>
  beforeDelete?: (params: DeleteParams<FilterType, OptionsType>) => Promise<DeleteParams<FilterType, OptionsType>>
  afterDelete?: (params: DeleteParams<FilterType, OptionsType>) => Promise<void>
}

export interface DAOParams<
  ModelType,
  IDKey extends keyof Omit<ModelType, ExcludedFields>,
  IDAutogenerated extends boolean,
  FilterType,
  UpdateType,
  ExcludedFields extends keyof ModelType,
  SortType,
  OptionsType,
> {
  defaultOptions?: OptionsType
  pageSize?: number
  associations?: DAOAssociation[]
  middlewares?: DAOMiddleware<ModelType, IDKey, IDAutogenerated, FilterType, UpdateType, ExcludedFields, SortType, OptionsType>[]
}

