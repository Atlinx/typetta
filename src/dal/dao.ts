import DataLoader from 'dataloader'
import objectHash from 'object-hash'
import { AbstractDAOContext } from './daoContext'
import { ConditionalPartialBy } from '../utils/utils'
import { PartialDeep } from 'type-fest'
import { deepMerge, getTraversing, setTraversing } from '@twinlogix/tl-commons'
import { Projection, ModelProjection, StaticProjection, GenericProjection, AnyProjection } from '../utils/types'
import { projection, getProjection, isProjectionIntersected, mergeProjections } from '../utils/projection'
import _ from 'lodash'

export enum SortDirection {
  ASC = 1,
  DESC = -1,
}

export type LogicalOperators<FilterType> = {
  $and?: LogicalOperators<FilterType>[] | FilterType[]
  $not?: LogicalOperators<FilterType> | FilterType
  $nor?: LogicalOperators<FilterType>[] | FilterType[]
  $or?: LogicalOperators<FilterType>[] | FilterType[]
}

export type ComparisonOperators<FieldType> = {
  $eq?: FieldType
  $gt?: FieldType
  $gte?: FieldType
  $in?: FieldType[]
  $lt?: FieldType
  $lte?: FieldType
  $ne?: FieldType
  $nin?: FieldType[]
}

export type ElementOperators<FieldType> = {
  $exists?: Boolean
  // $type
}

export type EvaluationOperators<FieldType> = {
  // $expr?
  // $jsonSchema
  // $mod
  // $regex
  $text?: {
    $search: String
    $language?: String
    $caseSensitive?: Boolean
    $diacriticSensitive?: Boolean
  }
  // $where
}

export type GeospathialOperators<FieldType> = {
  // $geoIntersect
  // $geoWithin
  $near?: {
    $geometry: {
      type: 'Point'
      coordinates: number[]
    }
    $maxDistance?: number
    $minDistance: number
  }
  $nearSphere?: {
    $geometry: {
      type: 'Point'
      coordinates: number[]
    }
    $maxDistance?: number
    $minDistance: number
  }
}

export type ArrayOperators<FieldType> = {
  $all?: FieldType[]
  // $elemMatch
  $size: number
}

export type ReferenceChecksResponse<T> =
  | true
  | {
      association: DAOAssociation
      record: PartialDeep<T>
      failedReferences: any[]
    }[]

export enum DAOAssociationType {
  ONE_TO_ONE,
  ONE_TO_MANY,
}

export enum DAOAssociationReference {
  INNER,
  FOREIGN,
}

export type DAOAssociation = {
  type: DAOAssociationType
  reference: DAOAssociationReference
  field: string //TODO: use recursivekeyof
  refFrom: string
  refTo: string
  dao: string
  buildFilter?: (keys: any[]) => any
  hasKey?: (record: any, key: any) => boolean
  extractField?: string
}

export type DAOComputedFields<ModelType, P extends true | StaticProjection<ModelType> | undefined | Projection<ModelType>> = {
  fieldsProjection: Projection<ModelType>
  requiredProjection: P
  compute: (record: ModelProjection<ModelType, P>) => Promise<PartialDeep<ModelType>>
}

export function projectionDependency<
  ModelType,
  P extends StaticProjection<ModelType>,
  IDKey extends keyof Omit<ModelType, ExcludedFields>,
  IDAutogenerated extends boolean,
  FilterType,
  UpdateType,
  ExcludedFields extends keyof ModelType,
  SortType,
  OptionsType,
>(args: { fieldsProjection: Projection<ModelType>; requiredProjection: P }): DAOMiddleware<ModelType, IDKey, IDAutogenerated, FilterType, UpdateType, ExcludedFields, SortType, OptionsType> {
  return {
    beforeFind: async (findParams) => {
      if (isProjectionIntersected(findParams.projection ? (findParams.projection as GenericProjection) : true, args.fieldsProjection ? (args.fieldsProjection as GenericProjection) : true)) {
        return {
          ...findParams,
          projection: mergeProjections((findParams.projection || true) as GenericProjection, args.requiredProjection as GenericProjection) as Projection<ModelType>,
        }
      }
      return findParams
    },
  }
}

export function buildComputedField<
  ModelType,
  P extends StaticProjection<ModelType>,
  IDKey extends keyof Omit<ModelType, ExcludedFields>,
  IDAutogenerated extends boolean,
  FilterType,
  UpdateType,
  ExcludedFields extends keyof ModelType,
  SortType,
  OptionsType,
>(args: {
  fieldsProjection: Projection<ModelType>
  requiredProjection: P
  compute: (record: ModelProjection<ModelType, P>) => Promise<PartialDeep<ModelType>>
}): DAOMiddleware<ModelType, IDKey, IDAutogenerated, FilterType, UpdateType, ExcludedFields, SortType, OptionsType> {
  return {
    beforeFind: projectionDependency<ModelType, P, IDKey, IDAutogenerated, FilterType, UpdateType, ExcludedFields, SortType, OptionsType>(args).beforeFind,
    afterFind: async (findParams, result) => {
      if (result && isProjectionIntersected(findParams.projection ? (findParams.projection as GenericProjection) : true, args.fieldsProjection ? (args.fieldsProjection as GenericProjection) : true)) {
        return deepMerge(result, await args.compute(result as ModelProjection<ModelType, P>))
      }
      return result
    },
  }
}

export type DAOResolver = {
  load: (parents: any[], projections: any) => Promise<any[]>
  match: (source: any, value: any) => boolean
}

export type FilterParams<FilterType, OptionsType> = {
  filter?: FilterType
  options?: OptionsType
}
export type FindOneParams<FilterType, ProjectionType, OptionsType> = FilterParams<FilterType, OptionsType> & {
  projection?: ProjectionType
}
export type FindParams<FilterType, ProjectionType, SortType, OptionsType> = FindOneParams<FilterType, ProjectionType, OptionsType> & {
  start?: number
  limit?: number
  sorts?: SortType
}

export type InsertParams<ModelType, IDKey extends keyof Omit<ModelType, ExcludedFields>, ExcludedFields extends keyof ModelType, IDAutogenerated extends boolean, OptionsType> = {
  record: ConditionalPartialBy<Omit<ModelType, ExcludedFields>, IDKey, IDAutogenerated>
  options?: OptionsType
}

export type UpdateParams<FilterType, UpdateType, OptionsType> = {
  filter: FilterType
  changes: UpdateType
  options?: OptionsType
}

export type ReplaceParams<FilterType, ModelType, ExcludedFields extends keyof ModelType, OptionsType> = {
  filter: FilterType
  replace: Omit<ModelType, ExcludedFields>
  options?: OptionsType
}

export type DeleteParams<FilterType, OptionsType> = {
  filter: FilterType
  options?: OptionsType
}

export interface DAO<
  ModelType,
  IDKey extends keyof Omit<ModelType, ExcludedFields>,
  IDAutogenerated extends boolean,
  FilterType,
  SortType,
  UpdateType,
  ExcludedFields extends keyof ModelType,
  OptionsType,
> {
  findMany<ProjectionType extends AnyProjection<ModelType> = true>(params: FindParams<FilterType, ProjectionType, SortType, OptionsType>): Promise<ModelProjection<ModelType, ProjectionType>[]>
  findFirst<ProjectionType extends AnyProjection<ModelType> = true>(params: FindOneParams<FilterType, ProjectionType, OptionsType>): Promise<ModelProjection<ModelType, ProjectionType> | null>
  findPage<ProjectionType extends AnyProjection<ModelType> = true>(
    params: FindParams<FilterType, ProjectionType, SortType, OptionsType>,
  ): Promise<{ totalCount: number; records: ModelProjection<ModelType, ProjectionType>[] }>
  exists(params: FilterParams<FilterType, OptionsType>): Promise<boolean>
  count(params: FilterParams<FilterType, OptionsType>): Promise<number>

  checkReferences(records: PartialDeep<ModelType> | PartialDeep<ModelType>[], options?: OptionsType): Promise<ReferenceChecksResponse<ModelType>>

  insertOne(params: InsertParams<ModelType, IDKey, ExcludedFields, IDAutogenerated, OptionsType>): Promise<Omit<ModelType, ExcludedFields>>
  updateOne(params: UpdateParams<FilterType, UpdateType, OptionsType>): Promise<void>
  updateMany(params: UpdateParams<FilterType, UpdateType, OptionsType>): Promise<void>
  replaceOne(params: ReplaceParams<FilterType, ModelType, ExcludedFields, OptionsType>): Promise<void>
  deleteOne(params: DeleteParams<FilterType, OptionsType>): Promise<void>
  deleteMany(params: DeleteParams<FilterType, OptionsType>): Promise<void>

  find<P extends AnyProjection<ModelType> = true>(filter: FilterType, projection?: P, sorts?: SortType, start?: number, limit?: number, options?: OptionsType): Promise<ModelProjection<ModelType, P>[]>
  findOne<P extends AnyProjection<ModelType> = true>(filter: FilterType, projection?: P, options?: OptionsType): Promise<ModelProjection<ModelType, P> | null>
  insert(record: ConditionalPartialBy<Omit<ModelType, ExcludedFields>, IDKey, IDAutogenerated>, options?: OptionsType): Promise<Omit<ModelType, ExcludedFields>>
  update<T extends Pick<ModelType, IDKey>>(record: T, changes: UpdateType, options?: OptionsType): Promise<void>
  replace<T extends Pick<ModelType, IDKey>>(record: T, replace: Omit<ModelType, ExcludedFields>, options?: OptionsType): Promise<void>
  delete<T extends Pick<ModelType, IDKey>>(record: T, options?: OptionsType): Promise<void>
}

export type DAOMiddleware<
  ModelType,
  IDKey extends keyof Omit<ModelType, ExcludedFields>,
  IDAutogenerated extends boolean,
  FilterType,
  UpdateType,
  ExcludedFields extends keyof ModelType,
  SortType,
  OptionsType,
> = {
  beforeFind?: (params: FindParams<FilterType, Projection<ModelType>, SortType, OptionsType>) => Promise<FindParams<FilterType, Projection<ModelType>, SortType, OptionsType>>
  afterFind?: (params: FindParams<FilterType, Projection<ModelType>, SortType, OptionsType>, result: PartialDeep<ModelType> | null) => Promise<PartialDeep<ModelType>>
  beforeInsert?: (params: InsertParams<ModelType, IDKey, ExcludedFields, IDAutogenerated, OptionsType>) => Promise<InsertParams<ModelType, IDKey, ExcludedFields, IDAutogenerated, OptionsType>>
  afterInsert?: (params: InsertParams<ModelType, IDKey, ExcludedFields, IDAutogenerated, OptionsType>, result: Omit<ModelType, ExcludedFields>) => Promise<Omit<ModelType, ExcludedFields>>
  beforeUpdate?: (params: UpdateParams<FilterType, UpdateType, OptionsType>) => Promise<UpdateParams<FilterType, UpdateType, OptionsType>>
  afterUpdate?: (params: UpdateParams<FilterType, UpdateType, OptionsType>) => Promise<void>
  beforeReplace?: (params: ReplaceParams<FilterType, ModelType, ExcludedFields, OptionsType>) => Promise<ReplaceParams<FilterType, ModelType, ExcludedFields, OptionsType>>
  afterReplace?: (params: ReplaceParams<FilterType, ModelType, ExcludedFields, OptionsType>) => Promise<void>
  beforeDelete?: (params: DeleteParams<FilterType, OptionsType>) => Promise<DeleteParams<FilterType, OptionsType>>
  afterDelete?: (params: DeleteParams<FilterType, OptionsType>) => Promise<void>
}

export interface DAOParams<
  ModelType,
  IDKey extends keyof Omit<ModelType, ExcludedFields>,
  IDAutogenerated extends boolean,
  FilterType,
  UpdateType,
  ExcludedFields extends keyof ModelType,
  SortType,
  OptionsType,
> {
  defaultOptions?: OptionsType
  pageSize?: number
  associations?: DAOAssociation[]
  middlewares?: DAOMiddleware<ModelType, IDKey, IDAutogenerated, FilterType, UpdateType, ExcludedFields, SortType, OptionsType>[]
}

export abstract class AbstractDAO<
  ModelType,
  IDKey extends keyof Omit<ModelType, ExcludedFields>,
  IDAutogenerated extends boolean,
  FilterType,
  SortType,
  UpdateType,
  ExcludedFields extends keyof ModelType,
  OptionsType,
> implements DAO<ModelType, IDKey, IDAutogenerated, FilterType, SortType, UpdateType, ExcludedFields, OptionsType>
{
  protected idField: IDKey
  protected daoContext: AbstractDAOContext
  protected associations: DAOAssociation[]
  protected middlewares: DAOMiddleware<ModelType, IDKey, IDAutogenerated, FilterType, UpdateType, ExcludedFields, SortType, OptionsType>[]
  protected pageSize: number
  protected resolvers: { [key: string]: DAOResolver | undefined }
  protected dataLoaders: Map<string, DataLoader<ModelType[IDKey], ModelType[] | null>>
  protected defaultOptions: OptionsType | undefined

  protected constructor({
    idField,
    daoContext,
    pageSize = 50,
    associations = [],
    middlewares = [],
    defaultOptions,
  }: { idField: IDKey; daoContext: AbstractDAOContext } & DAOParams<ModelType, IDKey, boolean, FilterType, any, ExcludedFields, SortType, OptionsType>) {
    this.dataLoaders = new Map<string, DataLoader<ModelType[IDKey], ModelType[]>>()
    this.idField = idField
    this.daoContext = daoContext
    this.pageSize = pageSize
    this.resolvers = {}
    this.associations = associations
    this.associations.forEach((association) => this.addResolver(association))
    this.middlewares = middlewares
    this.defaultOptions = defaultOptions
  }

  protected async beforeFind(params: FindParams<FilterType, Projection<ModelType>, SortType, OptionsType>): Promise<FindParams<FilterType, Projection<ModelType>, SortType, OptionsType>> {
    for (const middleware of this.middlewares) {
      if (middleware.beforeFind) {
        params = await middleware.beforeFind(params)
      }
    }
    return params
  }

  protected async afterFind(params: FindParams<FilterType, Projection<ModelType>, SortType, OptionsType>, result: PartialDeep<ModelType>): Promise<PartialDeep<ModelType>> {
    for (const middleware of this.middlewares) {
      if (middleware.afterFind) {
        result = await middleware.afterFind(params, result)
      }
    }
    return result
  }

  private async elabRecords<P extends AnyProjection<ModelType>>(params: FindParams<FilterType, P, SortType, OptionsType>, records: PartialDeep<ModelType>[]): Promise<ModelProjection<ModelType, P>[]> {
    const results = []
    for (let i = 0; i < records.length; i++) {
      results.push(await this.afterFind(params, records[i]))
    }
    return results as ModelProjection<ModelType, P>[]
  }

  async find<P extends AnyProjection<ModelType> = true>(
    filter: FilterType,
    projection?: P,
    sorts?: SortType,
    start?: number,
    limit?: number,
    options?: OptionsType,
  ): Promise<ModelProjection<ModelType, P>[]> {
    return this.findMany({ filter, projection, sorts, start, limit, options })
  }
  async findOne<P extends AnyProjection<ModelType> = true>(filter: FilterType, projection?: P, options?: OptionsType): Promise<ModelProjection<ModelType, P> | null> {
    return this.findFirst({ filter, projection, options })
  }

  async findMany<P extends AnyProjection<ModelType> = true>(params: FindParams<FilterType, P, SortType, OptionsType>): Promise<ModelProjection<ModelType, P>[]> {
    const newParams = await this.beforeFind(params)
    const records = await this._find(newParams)
    return this.elabRecords(params, records)
  }

  async findFirst<P extends AnyProjection<ModelType> = true>(params: FindOneParams<FilterType, P, OptionsType>): Promise<ModelProjection<ModelType, P> | null> {
    const newParams = await this.beforeFind({ ...params })
    const record = await this._findOne(newParams)
    if (record) {
      return (await this.elabRecords({ ...params }, [record]))[0]
    }
    return null
  }

  async findPage<P extends AnyProjection<ModelType> = true>(params: FindParams<FilterType, P, SortType, OptionsType>): Promise<{ totalCount: number; records: ModelProjection<ModelType, P>[] }> {
    const newParams = await this.beforeFind(params)
    const { totalCount, records } = await this._findPage(newParams)
    return {
      totalCount,
      records: await this.elabRecords(params, records as PartialDeep<ModelType>[]),
    }
  }

  async exists(params: FilterParams<FilterType, OptionsType>): Promise<boolean> {
    const newParams = await this.beforeFind({ ...params })
    return this._exists(newParams)
  }

  async count(params: FilterParams<FilterType, OptionsType>): Promise<number> {
    const newParams = await this.beforeFind({ ...params })
    return this._count(newParams)
  }

  async checkReferences(records: PartialDeep<ModelType> | PartialDeep<ModelType>[], options?: OptionsType): Promise<ReferenceChecksResponse<ModelType>> {
    const errors = []
    if (records) {
      const inputRecords = records instanceof Array ? records : [records]
      for (const association of this.associations) {
        if (association.reference === DAOAssociationReference.INNER) {
          const associationProjection = {}
          setTraversing(associationProjection, association.refTo, true)
          const resolver: DAOResolver = this.resolvers[association.field]!

          const associationFieldPathSplitted = association.field.split('.')
          associationFieldPathSplitted.pop()
          const parentPath = associationFieldPathSplitted.join('.')
          const parents = getTraversing(inputRecords, parentPath)
          const associatedRecords = await resolver.load(parents, associationProjection)

          for (const inputRecord of inputRecords) {
            const notFoundRefsFrom = getTraversing(inputRecord, association.refFrom).filter((refFrom) => {
              return !associatedRecords.find(
                (associatedRecord) => associatedRecord && getTraversing(associatedRecord, association.refTo).length > 0 && refFrom === getTraversing(associatedRecord, association.refTo)[0],
              )
            })
            if (notFoundRefsFrom.length > 0) {
              errors.push({ association, record: inputRecord, failedReferences: notFoundRefsFrom })
            }
          }
        }
      }
    }
    if (errors.length > 0) {
      return errors
    } else {
      return true
    }
  }

  // -----------------------------------------------------------------------
  // ---------------------------- ASSOCIATIONS -----------------------------
  // -----------------------------------------------------------------------
  private async load(
    keys: IDKey[],
    buildFilter: (keys: IDKey[]) => FilterType,
    hasKey: (record: ModelType, key: IDKey) => boolean,
    projection: Projection<ModelType>,
    loaderIdetifier: string = '',
  ): Promise<(ModelType | null | Error)[]> {
    const dataLoader = this.getDataLoader(buildFilter, hasKey, projection, loaderIdetifier)
    const loadedResults = await dataLoader.loadMany(keys)
    const results = []
    for (const loadedResult of loadedResults) {
      if (loadedResult instanceof Error) {
        throw loadedResult
      } else if (loadedResult !== null) {
        results.push(...loadedResult)
      }
    }
    return results
  }

  private getDataLoader(
    buildFilter: (keys: any[]) => FilterType,
    hasKey: (record: ModelType, key: any) => boolean,
    projection: Projection<ModelType>,
    loaderIdetifier: string,
  ): DataLoader<any, ModelType[] | null> {
    const hash = loaderIdetifier + '-' + objectHash(projection || null, { respectType: false, unorderedArrays: true })
    const dataLoader = this.dataLoaders.get(hash)
    if (dataLoader) {
      return dataLoader
    } else {
      const newDataLoader = new DataLoader<any, ModelType[] | null>(
        async (keys) => {
          const filter = buildFilter(keys as ModelType[IDKey][])
          const loadedResults: any[] = await this.findMany({ filter, projection })
          const orderedResults = []
          for (const key of keys) {
            orderedResults.push(loadedResults.filter((loadedResult) => hasKey(loadedResult, key)) || null)
          }
          return orderedResults
        },
        {
          maxBatchSize: this.pageSize,
        },
      )
      this.dataLoaders.set(hash, newDataLoader)
      return newDataLoader
    }
  }

  protected async resolveAssociations(dbObjects: any[], projections?: Projection<ModelType>): Promise<ModelType[]> {
    for (const association of this.associations) {
      if (projections) {
        let associationProjection = getProjection(projections as GenericProjection, association.field)
        if (associationProjection && projections !== true) {
          if (associationProjection !== true) {
            if (association.reference === DAOAssociationReference.INNER) {
              setTraversing(associationProjection, association.refTo, true)
            } else if (association.reference === DAOAssociationReference.FOREIGN) {
              setTraversing(associationProjection, association.refFrom, true)
            }
          }
          const resolver: DAOResolver = this.resolvers[association.field]!

          const associationFieldPathSplitted = association.field.split('.')
          const associationField = associationFieldPathSplitted.pop()
          if (associationField) {
            const parentPath = associationFieldPathSplitted.join('.')
            const parents = getTraversing(
              dbObjects.filter((dbObject) => dbObject != null),
              parentPath,
            )
            const associatedRecords = await resolver.load(parents, associationProjection)
            parents.forEach((parent) => {
              if (association.type === DAOAssociationType.ONE_TO_ONE) {
                parent[associationField] =
                  associatedRecords.find((value) => {
                    return resolver.match(parent, value)
                  }) || null
              } else if (association.type === DAOAssociationType.ONE_TO_MANY) {
                parent[associationField] =
                  associatedRecords.filter((value) => {
                    return resolver.match(parent, value)
                  }) || null
              }
            })
          }
        }
      }
    }
    return dbObjects
  }

  protected addResolver(association: DAOAssociation) {
    let resolver

    if (association.reference === DAOAssociationReference.INNER) {
      const refFrom = association.refFrom.split('.').pop()
      const refTo = association.refTo
      const linkedDAO = association.dao
      if (refFrom) {
        if (association.type === DAOAssociationType.ONE_TO_ONE) {
          resolver = {
            load: async (parents: any[], projections: any) => {
              const ids = parents.map((parent) => parent[refFrom]).filter((value, index, self) => value !== null && value !== undefined && self.indexOf(value) === index)

              return this.daoContext.dao(linkedDAO).load(
                ids,
                association.buildFilter ||
                  ((keys: any[]): FilterType => {
                    // @ts-ignore
                    return { [refTo]: { $in: keys } }
                  }),
                association.hasKey ||
                  ((record: ModelType, key: any): boolean => {
                    return (record as any)[refTo] === key
                  }),
                projections,
                refTo,
              )
            },
            match: (source: any, value: any): boolean => {
              return source[refFrom] === value[refTo]
            },
          }
        } else if (association.type === DAOAssociationType.ONE_TO_MANY) {
          resolver = {
            load: async (parents: any[], projections: any) => {
              const ids = parents
                .map((parent) => parent[refFrom])
                .filter((value) => value !== null && value !== undefined)
                .reduce((a, c) => [...a, ...c], [])
                .filter((value: any[], index: number, self: any) => self.indexOf(value) === index)

              return this.daoContext.dao(linkedDAO).load(
                ids,
                association.buildFilter ||
                  ((keys: any[]): FilterType => {
                    // @ts-ignore
                    return { [refTo]: { $in: keys } }
                  }),
                association.hasKey ||
                  ((record: ModelType, key: any): boolean => {
                    return (record as any)[refTo] === key
                  }),
                projections,
                refTo,
              )
            },
            match: (source: any, value: any): boolean => {
              return source[refFrom] && source[refFrom].includes(value[refTo])
            },
          }
        }
      }
    } else if (association.reference === DAOAssociationReference.FOREIGN) {
      const refFrom = association.refFrom
      const refTo = association.refTo.split('.').pop()
      const linkedDAO = association.dao
      if (refTo) {
        resolver = {
          load: async (parents: any[], projections: any) => {
            const ids = parents.map((parent) => parent[refTo]).filter((value, index, self) => value !== null && value !== undefined && self.indexOf(value) === index)

            return this.daoContext.dao(linkedDAO).load(
              ids,
              association.buildFilter ||
                ((keys: any[]): FilterType => {
                  // @ts-ignore
                  return { [refFrom]: { $in: keys } }
                }),
              association.hasKey ||
                ((record: ModelType, key: any): boolean => {
                  return (record as any)[refFrom] === key
                }),
              projections,
              refFrom,
            )
          },
          match: (source: any, value: any): boolean => {
            const tmp = getTraversing(value, refFrom)
            return tmp.includes(source[refTo])
          },
        }
      }
    }
    this.resolvers[association.field] = resolver
  }

  protected idFilter<T extends Pick<ModelType, IDKey>>(model: T): FilterType {
    return { [this.idField]: model[this.idField] } as unknown as FilterType
  }

  private async beforeInsert(
    params: InsertParams<ModelType, IDKey, ExcludedFields, IDAutogenerated, OptionsType>,
  ): Promise<InsertParams<ModelType, IDKey, ExcludedFields, IDAutogenerated, OptionsType>> {
    for (const middleware of this.middlewares) {
      if (middleware.beforeInsert) {
        params = await middleware.beforeInsert(params)
      }
    }
    return params
  }

  private async afterInsert(params: InsertParams<ModelType, IDKey, ExcludedFields, IDAutogenerated, OptionsType>, result: Omit<ModelType, ExcludedFields>): Promise<Omit<ModelType, ExcludedFields>> {
    for (const middleware of this.middlewares) {
      if (middleware.afterInsert) {
        result = await middleware.afterInsert(params, result)
      }
    }
    return result
  }

  async insert(record: ConditionalPartialBy<Omit<ModelType, ExcludedFields>, IDKey, IDAutogenerated>, options?: OptionsType): Promise<Omit<ModelType, ExcludedFields>> {
    return this.insertOne({ record, options })
  }

  async insertOne(params: InsertParams<ModelType, IDKey, ExcludedFields, IDAutogenerated, OptionsType>): Promise<Omit<ModelType, ExcludedFields>> {
    const newParams = await this.beforeInsert(params)
    const result = await this._insertOne(newParams)
    await this.afterInsert(newParams, result)
    return result
  }

  private async beforeUpdate(params: UpdateParams<FilterType, UpdateType, OptionsType>): Promise<UpdateParams<FilterType, UpdateType, OptionsType>> {
    for (const middleware of this.middlewares) {
      if (middleware.beforeUpdate) {
        params = await middleware.beforeUpdate(params)
      }
    }
    return params
  }

  private async afterUpdate(params: UpdateParams<FilterType, UpdateType, OptionsType>) {
    for (const middleware of this.middlewares) {
      if (middleware.afterUpdate) {
        await middleware.afterUpdate(params)
      }
    }
  }

  async update<T extends Pick<ModelType, IDKey>>(record: T, changes: UpdateType, options?: OptionsType): Promise<void> {
    return this.updateOne({ filter: this.idFilter(record), changes, options })
  }

  async updateOne(params: UpdateParams<FilterType, UpdateType, OptionsType>): Promise<void> {
    const newParams = await this.beforeUpdate(params)
    await this._updateOne(newParams)
    await this.afterUpdate(newParams)
  }

  async updateMany(params: UpdateParams<FilterType, UpdateType, OptionsType>): Promise<void> {
    const newParams = await this.beforeUpdate(params)
    await this._updateMany(newParams)
    await this.afterUpdate(newParams)
  }

  private async beforeReplace(params: ReplaceParams<FilterType, ModelType, ExcludedFields, OptionsType>): Promise<ReplaceParams<FilterType, ModelType, ExcludedFields, OptionsType>> {
    for (const middleware of this.middlewares) {
      if (middleware.beforeReplace) {
        params = await middleware.beforeReplace(params)
      }
    }
    return params
  }

  private async afterReplace(params: ReplaceParams<FilterType, ModelType, ExcludedFields, OptionsType>): Promise<void> {
    for (const middleware of this.middlewares) {
      if (middleware.afterReplace) {
        await middleware.afterReplace(params)
      }
    }
  }

  async replace<T extends Pick<ModelType, IDKey>>(record: T, replace: Omit<ModelType, ExcludedFields>, options?: OptionsType): Promise<void> {
    return this.replaceOne({ filter: this.idFilter(record), replace, options })
  }

  async replaceOne(params: ReplaceParams<FilterType, ModelType, ExcludedFields, OptionsType>): Promise<void> {
    const newParams = await this.beforeReplace(params)
    await this._replaceOne(newParams)
    await this.afterReplace(newParams)
  }

  private async beforeDelete(params: DeleteParams<FilterType, OptionsType>): Promise<DeleteParams<FilterType, OptionsType>> {
    for (const middleware of this.middlewares) {
      if (middleware.beforeDelete) {
        params = await middleware.beforeDelete(params)
      }
    }
    return params
  }

  private async afterDelete(params: DeleteParams<FilterType, OptionsType>): Promise<void> {
    for (const middleware of this.middlewares) {
      if (middleware.afterDelete) {
        await middleware.afterDelete(params)
      }
    }
  }

  async delete<T extends Pick<ModelType, IDKey>>(record: T, options?: OptionsType): Promise<void> {
    return this.deleteOne({ filter: this.idFilter(record), options })
  }

  async deleteOne(params: DeleteParams<FilterType, OptionsType>): Promise<void> {
    const newParams = await this.beforeDelete(params)
    await this._deleteOne(newParams)
    await this.afterDelete(newParams)
  }

  async deleteMany(params: DeleteParams<FilterType, OptionsType>): Promise<void> {
    const newParams = await this.beforeDelete(params)
    await this._deleteMany(newParams)
    await this.afterDelete(newParams)
  }

  // -----------------------------------------------------------------------
  // ------------------------------ ABSTRACTS ------------------------------
  // -----------------------------------------------------------------------
  protected abstract _find(params: FindParams<FilterType, Projection<ModelType>, SortType, OptionsType>): Promise<PartialDeep<ModelType>[]>
  protected abstract _findOne(params: FindOneParams<FilterType, Projection<ModelType>, OptionsType>): Promise<PartialDeep<ModelType> | null>
  protected abstract _findPage(params: FindParams<FilterType, Projection<ModelType>, SortType, OptionsType>): Promise<{ totalCount: number; records: PartialDeep<ModelType>[] }>
  protected abstract _exists(params: FilterParams<FilterType, OptionsType>): Promise<boolean>
  protected abstract _count(params: FilterParams<FilterType, OptionsType>): Promise<number>
  protected abstract _insertOne(params: InsertParams<ModelType, IDKey, ExcludedFields, IDAutogenerated, OptionsType>): Promise<Omit<ModelType, ExcludedFields>>
  protected abstract _updateOne(params: UpdateParams<FilterType, UpdateType, OptionsType>): Promise<void>
  protected abstract _updateMany(params: UpdateParams<FilterType, UpdateType, OptionsType>): Promise<void>
  protected abstract _replaceOne(params: ReplaceParams<FilterType, ModelType, ExcludedFields, OptionsType>): Promise<void>
  protected abstract _deleteOne(params: DeleteParams<FilterType, OptionsType>): Promise<void>
  protected abstract _deleteMany(params: DeleteParams<FilterType, OptionsType>): Promise<void>
}
