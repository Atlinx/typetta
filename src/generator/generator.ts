import { TypeScriptMongoosePluginConfig } from './config'
import { TsMongooseAbstractGenerator } from './generators/abstractGenerator'
import { TsMongooseSchemaGenerator } from './generators/schemaGenerator'
import { TsMongooseDAOGenerator } from './generators/daoGenerator'

export type TsMongooseGeneratorField = {
  name: string
  type: string | { embed?: string; innerRef?: string; foreignRef?: string; refFrom?: string; refTo?: string }
  mongooseType: string
  required: boolean
  isID: boolean
  isAutogenerated: boolean
  isList: boolean
  isExcluded: boolean
}

export type TsMongooseGeneratorNode = {
  type?: string
  code: string
  name: string
  prefixedName: string
  isEntity: boolean
  collection: string
  interfaces: string[]
  fields: TsMongooseGeneratorField[]
}

export class TsMongooseGenerator {
  private _generators: TsMongooseAbstractGenerator[]

  constructor(config: TypeScriptMongoosePluginConfig) {
    this._generators = [new TsMongooseSchemaGenerator(config), new TsMongooseDAOGenerator(config)]
  }

  public generate(nodes: TsMongooseGeneratorNode[]): string {
    nodes = nodes.filter((node) => node.type)

    const interfacesMap = new Map<string, TsMongooseGeneratorNode>()
    nodes.filter((node) => node.type === 'interface').forEach((interf) => interfacesMap.set(interf.code, interf))

    const typesMap = new Map<string, TsMongooseGeneratorNode>()
    nodes.filter((node) => node.type === 'type').forEach((type) => typesMap.set(type.code, type))

    this.checkIds(typesMap, interfacesMap)
    this.checkReferences(typesMap, interfacesMap)
    this.checkSubClassesMongoDirectives(typesMap, interfacesMap)

    const imports = this._generators
      .map((generator) => {
        return generator.generateImports()
      })
      .reduce((a, c) => [...a, ...c], [])

    const definitions = nodes.map((node) => {
      const definition = this._generators
        .map((generator) => generator.generateDefinition(node, typesMap, interfacesMap))
        .filter((definition) => definition !== '')
        .join('\n\n')
      return [this._generateTitle(node), definition].join('\n\n')
    })

    const exports = this._generators.map((generator) => generator.generateExports(typesMap, interfacesMap))

    return [imports.join('\n'), definitions.join('\n\n\n\n'), exports.join('\n\n')].join('\n\n')
  }

  private _generateTitle(node: TsMongooseGeneratorNode): string {
    let comment = '//' + '-'.repeat(80) + '\n'
    comment += '//' + '-'.repeat((80 - node.name.length - ((node.name.length % 2) + 1)) / 2) + ' ' + node.name.toUpperCase() + ' ' + '-'.repeat((80 - node.name.length - 1) / 2) + '\n'
    comment += '//' + '-'.repeat(80)
    return comment
  }

  private checkIds(typesMap: Map<String, TsMongooseGeneratorNode>, interfacesMap: Map<String, TsMongooseGeneratorNode>) {
    Array.from(typesMap.values())
      .concat(Array.from(interfacesMap.values()))
      .filter((type) => this._isEntity(type, interfacesMap))
      .forEach((type) => {
        const id = this._findID(type, interfacesMap)
        if (!id) {
          throw new Error(`Type ${type.name} requires an @id field being a @mongoEntity.`)
        }
      })
  }

  private checkReferences(typesMap: Map<String, TsMongooseGeneratorNode>, interfacesMap: Map<String, TsMongooseGeneratorNode>) {
    Array.from(typesMap.values())
      .concat(Array.from(interfacesMap.values()))
      .forEach((type) => {
        type.fields.forEach((field) => {
          if (typeof field.type !== 'string') {
            if (field.type.innerRef) {
              const refType = this._findNode(field.type.innerRef, typesMap, interfacesMap)
              if (!refType) {
                throw new Error(`Field ${field.name} of type ${type.name} has a reference to ${field.type.innerRef} that cannot be resolved.`)
              }
              if (!this._isEntity(refType, interfacesMap)) {
                throw new Error(`Field ${field.name} of type ${type.name} has a reference to ${field.type.innerRef} that isn't a mongoEntity.`)
              }
              if (field.type.refFrom) {
                const refFromField = this._findField(type, field.type.refFrom, typesMap, interfacesMap)
                if (!refFromField) {
                  throw new Error(`Field ${field.name} of type ${type.name} has a reference to ${field.type.innerRef} with refFrom ${field.type.refFrom} that cannot be resolved.`)
                }
              }
              if (field.type.refTo) {
                const refToField = this._findField(refType, field.type.refTo, typesMap, interfacesMap)
                if (!refToField) {
                  throw new Error(`Field ${field.name} of type ${type.name} has a reference to ${field.type.innerRef} with refTo ${field.type.refTo} that cannot be resolved.`)
                }
              }
            } else if (field.type.foreignRef) {
              const refType = this._findNode(field.type.foreignRef, typesMap, interfacesMap)
              if (!refType) {
                throw new Error(`Field ${field.name} of type ${type.name} has a reference to ${field.type.foreignRef} that cannot be resolved.`)
              }
              if (field.type.refFrom) {
                const refFromField = this._findField(refType, field.type.refFrom, typesMap, interfacesMap)
                if (!refFromField) {
                  throw new Error(`Field ${field.name} of type ${type.name} has a reference to ${field.type.foreignRef} with refFrom ${field.type.refFrom} that cannot be resolved.`)
                }
              }
              if (field.type.refTo) {
                const refToField = this._findField(type, field.type.refTo, typesMap, interfacesMap)
                if (!refToField) {
                  throw new Error(`Field ${field.name} of type ${type.name} has a reference to ${field.type.foreignRef} with refTo ${field.type.refTo} that cannot be resolved.`)
                }
              }
            }
          }
        })
      })
  }

  private checkSubClassesMongoDirectives(typesMap: Map<String, TsMongooseGeneratorNode>, interfacesMap: Map<String, TsMongooseGeneratorNode>) {
    Array.from(typesMap.values()).forEach((type) => {
      const interfacesFieldsMap = new Map<string, TsMongooseGeneratorField>()
      type.interfaces
        .map((interf) => interfacesMap.get(interf)!.fields)
        .reduce((a, c) => [...a, ...c], [])
        .forEach((field) => interfacesFieldsMap.set(field.name, field))

      type.fields.forEach((typeField) => {
        const interfaceField = interfacesFieldsMap.get(typeField.name)
        if (interfaceField) {
          if (typeof interfaceField.type === 'string') {
            if (typeof typeField.type !== 'string' || interfaceField.type !== typeField.type) {
              throw new Error(`${typeField.name} field type of ${type.name} differs from the type of the same field in its interface.`)
            }
          } else if (interfaceField.type.embed) {
            if (typeof typeField.type === 'string' || typeField.type.embed !== interfaceField.type.embed) {
              throw new Error(`${typeField.name} field of ${type.name} can't override the mongo directive of its interface.`)
            }
          } else if (interfaceField.type.foreignRef || interfaceField.type.innerRef) {
            if (typeof typeField.type === 'string' || typeField.type.foreignRef || typeField.type.innerRef) {
              throw new Error(`${typeField.name} field of ${type.name} can't override the mongo directive of its interface.`)
            } else {
              typeField.type = interfaceField.type
            }
          }
        }
      })
    })
  }

  protected _isEntity(node: TsMongooseGeneratorNode, interfacesMap: Map<String, TsMongooseGeneratorNode>): boolean {
    let res = node.isEntity
    if (!res) {
      res = node.interfaces.filter((interf) => interfacesMap.get(interf)!.isEntity).length > 0
    }
    return res
  }

  protected _findID(node: TsMongooseGeneratorNode, interfacesMap: Map<String, TsMongooseGeneratorNode>): TsMongooseGeneratorField {
    let res = node.fields.find((field) => field.isID)
    if (!res) {
      const ids = node.interfaces.map((interf) => interfacesMap.get(interf)).map((interf) => interf!.fields.find((field) => field.isID))
      if (ids.length == 1) {
        res = ids[0]
      }
    }
    //@ts-ignore
    return res
  }

  protected _findNode(code: string, typesMap: Map<String, TsMongooseGeneratorNode>, interfacesMap: Map<String, TsMongooseGeneratorNode>): TsMongooseGeneratorNode {
    let res = typesMap.get(code)
    if (!res) {
      res = interfacesMap.get(code)
    }
    //@ts-ignore
    return res
  }

  protected _findField(
    node: TsMongooseGeneratorNode,
    fieldPath: string,
    typesMap: Map<String, TsMongooseGeneratorNode>,
    interfacesMap: Map<String, TsMongooseGeneratorNode>,
    //@ts-ignore
  ): TsMongooseGeneratorField {
    const fieldPathSplitted = fieldPath.split('.')
    if (fieldPathSplitted.length == 1) {
      return node.fields.find((f) => f.name === fieldPathSplitted[0])!
    } else {
      const key = fieldPathSplitted.shift()
      const tmpField = node.fields.find((f) => f.name === key)!
      if (typeof tmpField.type !== 'string' && tmpField.type.embed) {
        const embeddedType = this._findNode(tmpField.type.embed, typesMap, interfacesMap)
        return this._findField(embeddedType, fieldPathSplitted.join('.'), typesMap, interfacesMap)
      }
    }
  }
}
