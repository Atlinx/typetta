# Entities

A **data model** is made up of a set of entities. Such entities in Typetta are defined in **GraphQL** language, following the principles and syntax included in the official specification on [graphql.org](https://graphql.org/learn/){:target="_blank"}.

  - [Entity definition](#entity-definition)
  - [Stored Entity](#stored-entity)
    - [MongoDB Entity](#mongodb-entity)
    - [SQL Entity](#sql-entity)
  - [ID](#id)
  - [Enumerations](#enumerations)
  - [Embedded Entities](#embedded-entities)
  - [Alias](#alias)
  - [Excluded Fields](#excluded-fields)
  
## Entity definition

The basic definition of an entity is therefore that of a GraphQL type with a list of fields:

```typescript
type User {
  id: ID!
  firstName: String
  lastName: String
}
```

Note that, according GraphQL syntax, each field can be annotated as required or optional by adding or not the `!` operator after the type name.

Without further specifications, an entity such as the previous one will only produce the relative TypeScript type. No data access components will be generated as it does not appear to be an entity directly stored on a data source.

## Stored Entity

For an entity to be connected to its data structure on a data source and to allow the related CRUD operations, it must be explicitly annotated with a GraphQL directive. There are currently two database drivers available in Typetta, one for SQL databases and one for MongoDB, and two related directives `@sqlEntity` and `@mongoEntity`.

Once one of these annotations has been added, the entity is coupled to its data structure: to the table on SQL or to the collection on MongoDB.

### MongoDB Entity

To specify to the system that an entity is binded to a MongoDB collection, it must be defined as follows:

```typescript
type User @mongoEntity {
  id: ID!
  firstName: String
  lastName: String
}
```

`@mongoEntity` directive also accepts two optional params:
- `source`: represents the MongoDB database where the collection this entity is binded to resides. It is a logical label whose configuration will be set on the DAOContext. The default is `default`.

- `collection`: represents the MongoDB collection name, the default is the pluralized camel case entity name (so in the example above it would be `users`).

Following a complete example:
```typescript
type User @mongoEntity(source: "secondary-database", collection: "_users") {
  id: ID!
  firstName: String
  lastName: String
}
```

### SQL Entity

To specify to the system that an entity is binded to a SQL table, it must must be defined as follows:
```typescript
type User @sqlEntity {
  id: ID!
  firstName: String
  lastName: String
}
```

`@sqlEntity` directive also accepts two optional params:
- `source`: represents the SQL database where the table this entity is binded to resides. It is a logical label whose configuration will be set on the DAOContext. The default is `default`.

- `table`: represents the SQL table name, the default is the pluralized camel case entity name (so in the example above it would be `users`).

Following a complete example:
```typescript
type User @sqlEntity(source: "secondary-database", table: "_users") {
  id: ID!
  firstName: String
  lastName: String
}
```

## ID

Each stored entity needs a unique identifier. Any entity field can be annotated as `@id` as long as it has a scalar type and not another entity type. There is no correlation between the scalar GraphQL ID and the entity identifier.

To define the entity identifier you need to add the `@id` directive as in the following example:
```typescript
type User @mongoEntity {
  id: ID! @id
  firstName: String
  lastName: String
}
```


This directive also receives an optional `from` parameter which can take the following values:
- `db`: when the id is auto-generated by the DB, be it a SQL auto-increment integer or a MongoDB ObjectID or whatever the database supports.

```typescript
type User @mongoEntity {
  id: String! @id(from: "db") @alias(value: "_id")
  name: String!
}
```

- `user`: when the id is manually generated by the user, it will therefore be a mandatory field of every insert operation.

- `generator`: when the id is auto-generated by Typetta with configurable logic at DAOContext or single DAO level. An ID generator can be specified for each scalar and it will then be invoked for all fields of that specific scalar annotated with the `@id` directive. 

A simple example of `generator` policy can be the following where all entites identifiers are of type ID and must be managed as UUIDs auto-generated by the system. To achieve this, the DAOContext can then be configured as follows:

```typescript
import { v4 as uuidv4 } from 'uuid'

const daoContext = new DAOContext({
  scalars: {
    ID: {
      generator: () => uuidv4()
    }
  }
});
```

If you want different behavior for a single DAO, you can create an override like the following:

```typescript
import { v4 as uuidv4 } from 'uuid'

const daoContext = new DAOContext({
  scalars: {
    ID: {
      generator: () => uuidv4()
    }
  }
  overrides: {
    user: {
      scalars: {
        ID: {
          generator: () => 'user_' + uuidv4()
        }
      }
    }
  }
});
```

## Enumerations

The GraphQL specification provides for the definition of enumerations with the following syntax:
```typescript
enum UserType {
  ADMINISTRATOR
  CUSTOMER
}
```

An enumeration can be used just like a scalar to define the fields of an entity, as in the following example:
```typescript
type User {
  id: ID!
  firstName: String
  lastName: String
  type: UserType!
}
```

Typetta supports enumerations both at TypeScript and database level. They are serialized to string data type by default on both SQL and MongoDB.

## Embedded Entities

An embedded entity is an entity not directly stored in a dedicated SQL table or MongoDB collection, but included only inside another entity with a logic of composition. Embedded entities are a typical concept of document databases, which however can also be partially supported by SQL databases, as described below.

In Typetta each entity can have one or more fields which are not of scalar type by refer to embedded entities. These referred entities cannot be annotated as `@sqlEntity` or `@mongoEntity`. Here is a simple example:

```typescript
type Address {
  street: String
  city: String
  district: String
  zipcode: String
  country: String
}

type User @mongoEntity {
  id: ID! @id
  firstName: String
  lastName: String
  address: Address
}
```

Typetta offers the most advanced support to embedded entities on MongoDB, which are translated into embedded documents, thus giving the possibility to select, filter and sort the fields of them. On SQL databases these entities are instead flattened on multiple columns of the root table, offering also in this case the possibility to select, filter and sort. However, embedded entity arrays are not supported on SQL due to database limits.

## Alias

Each field of a stored entity has a direct correspondence with the binded SQL column or the binded key of the MongoDB document and this correspondence is given by the name of the field itself. If you want to decouple the name of the entity of the data model from the database structure, you can use the `@alias` directive as following:

```typescript
type User @mongoEntity {
  id: ID! @id
  firstName: String @alias(value: "name")
  lastName: String @alias(value: "surname")
  address: Address
}
```

In the above example the generated TypeScript type will have the fields `firstName: string` and `lastName: string`, while the MongoDB documents will have two keys `name` and `surname`.

## Excluded Fields

You can define fields in the data model that have no correspondence in the SQL table or in the MongoDB collection. These fields are then reflected on the TypeScript data type but are neither serialized nor deserialized on the database.

To define an excluded field you can use the `@exclude` directive as follows:

```typescript
type User @mongoEntity {
  id: ID! @id
  firstName: String
  lastName: String
  excludedField: String @exclude
}
```